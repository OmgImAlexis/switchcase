(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){(function(){"use strict";const matches=(value,pattern,functional,routing)=>{const type=typeof value;if(typeof pattern!=="object"&&type!=="object"){if(value===pattern){return true}if(routing&&type==="string"&&typeof pattern==="string"){const pparts=pattern.split("/"),vparts=value.split("/");if(pparts[0]===""){pparts.shift()}if(vparts[0]===""){vparts.shift()}let part;if(pparts.length!==vparts.length){return false}while(pparts.length>0){const ppart=pparts.shift(),vpart=vparts.shift();if(ppart[0]===":"){if(!routing.params){routing.params={}}let value=vpart;try{value=JSON.parse(value)}catch(e){true}routing.params[ppart.substring(1)]=value}else if(vpart!==ppart){return false}}return true}}if(pattern instanceof Date){if(value instanceof Date){return pattern.getTime()===value.getTime()}return false}if(pattern instanceof RegExp){if(["boolean","number","string"].includes(type)){return pattern.test(value)}return false}if(pattern instanceof Function){return!!pattern(value)}return Object.keys(pattern).every(key=>{let pvalue=pattern[key],ptype=typeof pvalue,test=value=>value===pvalue;if(ptype==="undefined"||pvalue&&ptype==="object"&&Object.keys(pvalue).length===0){return true}if(key.startsWith("/")){const i=key.lastIndexOf("/");if(i>0){try{const regexp=new RegExp(key.substring(1,i),key.substring(i+1));test=(key=>regexp.test(key))}catch(e){true}}}else if(key.includes("=>")){try{test=Function("return "+key)()}catch(e){true}}return Object.keys(value).every(vkey=>{let vtest=()=>vkey===key;if(vkey.startsWith("/")){const i=vkey.lastIndexOf("/");if(i>0){try{const regexp=new RegExp(vkey.substring(1,i),vkey.substring(i+1));vtest=regexp.test(key)}catch(e){true}}}else if(vkey.includes("=>")){try{vtest=Function("return "+vkey)()}catch(e){true}}if(test(vkey)||vtest()){const vvalue=value[vkey],vtype=typeof vvalue;if(functional&&ptype==="function"){return pvalue(vvalue)}if(pvalue&&ptype==="object"&&vtype==="object"){return vvalue?matches(vvalue,pvalue,functional):false}return pvalue===vvalue}return true})})},deepFreeze=data=>{if(data&&typeof data==="object"){Object.freeze(data);Object.keys(data).forEach(key=>deepFreeze(data[key]))}return data},getPath=object=>{if(object.path){return object.path}if(object.location&&object.location.pathname){return object.path=object.location.pathname}if(object.url||object.URL||object.newURL){if(!object.location){object.location=new URL(object.url||object.URL||object.newURL)}if(object.location.pathname){return object.path=object.location.pathname}return object.path=new URL(object.url||object.URL||object.newURL).pathname}},switchcase=(cases={},defaults={})=>{let switches=[];if(defaults&&typeof defaults!=="object"){defaults={strict:defaults}}if(cases!=null&&typeof cases[Symbol.iterator]==="function"){switches=cases.slice()}else{Object.keys(cases).forEach(key=>{let test=key;try{test=Function("return "+key)()}catch(e){true}switches.push([test,cases[key]])})}const switcher=Function("defaults","switches","matches","deepFreeze","getPath","switcher",`return ${defaults.async?"async ":""}(value,options={},...args) => {\n\tdelete options.pathRouter;\n\tdelete options.continuable;\n\toptions = Object.assign({},defaults,options);\n\tif(options.pathRouter) { options.continuable = true; }\n\tif(options.continuable) { options.call = true; }\n\tlet target = value,\n\t\tsetParams;\n\tif(options.pathRouter) {\n\t\tconst type = typeof(options.pathRouter.route);\n\t\tif(type==="function") {\n\t\t\ttarget = options.pathRouter.route(value);\n\t\t} else if(type==="string") {\n\t\t\ttarget = value[options.pathRouter.route];\n\t\t} else if(value.req) {\n\t\t\ttarget = getPath(value.req);\n\t\t} else if(value.request) {\n\t\t\ttarget = getPath(value.request);\n\t\t} else {\n\t\t\ttarget = getPath(value);\n\t\t}\n\t\tsetParams = options.pathRouter.setParams;\n\t\tif(!setParams) {\n\t\t\tsetParams = (value,params) => {\n\t\t\t\tif(value.req) {\n\t\t\t\t\tvalue.req.params = Object.assign({},value.req.params,params);\n\t\t\t\t} else if(value.request) {\n\t\t\t\t\tvalue.request.params = Object.assign({},value.request.params,params);\n\t\t\t\t} else {\n\t\t\t\t\tvalue.params = Object.assign({},value.params,params);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\tconst routing = options.pathRouter ? {} : null;\n\tlet results; // for collecting items when using as an object matcher\n\tfor(let item of switches) {\n\t\tconst key = Array.isArray(item) ? item[0] : item,\n\t\t\ttype = typeof(key);\n\t\tlet pattern = key,\n\t\t\tresult = item[1];\n\t\tif(key===item) { // swap target and pattern if using for object matching\n\t\t\ttarget = key;\n\t\t\tpattern = value;\n\t\t}\n\t\tif(key && key!==item && type==="object"  && !Object.isFrozen(key)) { // doesn't check deep but good enough and fast\n\t\t\tdeepFreeze(key);\n\t\t}\n\t\tif((key && (type==="object" || routing) && matches(target,pattern,result===undefined ? true : options.functionalMatch,routing))\n\t\t\t\t|| (result!==undefined && type==="function" && ${defaults.async?"await ":""} key(target,...args))\n\t\t\t\t|| (result!==undefined && options.strict && key===target)\n\t\t\t\t|| (result!==undefined && !options.strict && key==target))\t{\n\t\t\tif(result===undefined) { // case is an object to match\n\t\t\t\tif(!results) { results = []; }\n\t\t\t\tresults.push(target);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(typeof(result)==="function" && options.call) {\n\t\t\t\tif(setParams && routing.params) {\n\t\t\t\t\tsetParams(value,routing.params);\n\t\t\t\t}\n\t\t\t\tconst resolved = ${defaults.async?"await ":""} result(value,...args);\n\t\t\t\tif(resolved!==undefined || !options.continuable) { return resolved; }\n\t\t\t\tif(options.continuable) { continue; }\n\t\t\t\tresult = resolved;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst result = options.call && typeof(switcher().otherwise)==="function" ? ${defaults.async?"await ":""} switcher().otherwise(value) : switcher().otherwise;\n\treturn result === undefined ? results : result;\n}`)(defaults,switches,matches,deepFreeze,getPath,()=>switcher);switcher.otherwise=cases.default;switcher.case=((test,value)=>{switches.push([test,value]);return switcher});switcher.route=((test,value)=>{defaults.pathRouter=true;switches.push([test,value]);return switcher});switcher.default=(value=>{switcher.otherwise=value;return switcher});switcher.match=(value=>switcher(value));switcher.handle=switcher.match;return switcher};if(typeof module!=="undefined"){module.exports=switchcase}if(typeof window!=="undefined"){window.switchcase=switchcase}})()},{}]},{},[1]);